using System.Reflection;
using System.Text;
using Ithline.Extensions.Http.SourceGeneration.Patterns;
using Ithline.Extensions.Http.SourceGeneration.Specs;
using Microsoft.CodeAnalysis;

namespace Ithline.Extensions.Http.SourceGeneration;

public sealed partial class RouteGenerator
{
    private sealed class Emitter
    {
        private static readonly AssemblyName _assemblyName = typeof(Emitter).Assembly.GetName();
        private const string StringBuilderPool = nameof(StringBuilderPool);
        private const string RouteBuilder = "_sb";

        private readonly SourceGenerationSpec _spec;
        private readonly SourceWriter _writer = new();

        public Emitter(SourceGenerationSpec spec)
        {
            _spec = spec;
        }

        public void Emit(SourceProductionContext ctx)
        {
            if (_spec.Types.Count == 0)
            {
                return;
            }

            _writer.WriteLine("""
                // <auto-generated/>

                #nullable enable annotations
                #nullable disable warnings

                // Suppress warnings about [Obsolete] member usage in generated code.
                #pragma warning disable CS0612, CS0618
                """);

            foreach (var rootType in _spec.Types)
            {
                using (_writer.EmitStartBlock($"namespace {rootType.Namespace}"))
                {
                    this.EmitType(rootType);
                }
            }

            ctx.AddSource($"GeneratedRoutes.g.cs", _writer.ToSourceText());
        }

        private void EmitType(TypeSpec type)
        {
            using (_writer.EmitStartBlock($"partial {type.Keyword} {type.TypeName}"))
            {
                var first = true;
                foreach (var method in type.Methods ?? [])
                {
                    if (!first)
                    {
                        _writer.WriteLine();
                    }
                    first = false;

                    this.EmitMethod(method);
                }

                foreach (var subType in type.Types ?? [])
                {
                    if (!first)
                    {
                        _writer.WriteLine();
                    }
                    first = false;

                    this.EmitType(subType);
                }
            }
        }

        private void EmitMethod(MethodSpec method)
        {
            var signature = new StringBuilder();
            {
                if (!string.IsNullOrWhiteSpace(method.Modifiers))
                {
                    signature.Append(method.Modifiers).Append(" ");
                }

                signature.Append("string ").Append(method.Name);

                var first = true;
                signature.Append("(");
                foreach (var p in method.Parameters)
                {
                    if (!first)
                    {
                        signature.Append(", ");
                    }
                    first = false;

                    if (p.IsParams)
                    {
                        signature.Append("params ");
                    }

                    signature.Append(p.Type.FullyQualifiedName);
                    signature.Append(" ");
                    signature.Append(p.Name);
                }
                signature.Append(")");
            }

            //_writer.WriteLine($"""
            //    /// <summary>
            //    /// Raw pattern used to generate <see cref="{method.Name}({string.Join(", ", method.Parameters.Select(t => t.Type))})"/>.
            //    /// </summary>
            //    """);
            //_writer.WriteLine($"public const string _{method.Name} = \"{method.Pattern.RawText}\";");
            //_writer.WriteLine();
            _writer.WriteLine($"""[global::System.CodeDom.Compiler.GeneratedCodeAttribute("{_assemblyName.Name}", "{_assemblyName.Version}")]""");
            using (_writer.EmitStartBlock(signature.ToString()))
            {
                if (CanEmitInline(method))
                {
                    this.EmitMethodBodyInline(method);
                }
                else
                {
                    this.EmitMethodBodyBuilder(method);
                }
            }
        }

        private void EmitMethodBodyInline(MethodSpec method)
        {
            var sb = new StringBuilder();
            foreach (var segment in method.Pattern.PathSegments)
            {
                sb.Append('/');
                foreach (var part in segment.Parts)
                {
                    if (part is RoutePatternPartLiteral literalPart)
                    {
                        var content = method.LowercaseUrls
                            ? literalPart.Content.ToLowerInvariant()
                            : literalPart.Content;
                        sb.Append(content);
                    }
                    else if (part is RoutePatternPartSeparator separatorPart)
                    {
                        sb.Append(separatorPart.Content);
                    }
                    else if (part is RoutePatternPartParameter parameterPart)
                    {
                        var parameter = method.GetParameter(parameterPart.Name)!;
                        sb.Append($"{{{parameter.Name}}}");
                    }
                }
            }

            if (sb.Length is 0 || (method.AppendTrailingSlash && sb[^1] is not '/'))
            {
                sb.Append('/');
            }

            _writer.WriteLine($"return \"{sb}\";");
        }

        private void EmitMethodBodyBuilder(MethodSpec method)
        {
            const string AppendSlash = $"{RouteBuilder}.Append('/');";

            _writer.WriteLine($"{_spec.StringBuilder} {RouteBuilder} = {_spec.GeneratedRouteHelper}.{StringBuilderPool}.Get();");
            using (_writer.EmitStartBlock("try"))
            {
                _writer.WriteLine(AppendSlash);
                var pathSegments = method.Pattern.PathSegments;
                for (var i = 0; i < pathSegments.Count; i++)
                {
                    var segment = pathSegments[i];

                    var shouldAppendSlash = i > 0;
                    string? bufferedSeparator = null;
                    foreach (var part in segment.Parts)
                    {
                        if (part is RoutePatternPartParameter parameterPart)
                        {
                            var parameter = method.GetParameter(parameterPart.Name)!;
                            if (parameterPart.IsOptional || parameterPart.IsCatchAll)
                            {
                                using (_writer.EmitStartBlock($"if ({parameter.Name} is not null)"))
                                {
                                    this.WriteLineIf(shouldAppendSlash, AppendSlash);
                                    shouldAppendSlash = false;

                                    // write buffered value inside the optional parameter
                                    this.WriteLineIf(bufferedSeparator is not null, bufferedSeparator!);
                                    bufferedSeparator = null;

                                    this.EmitParameter(parameter.Name, parameter.RequiresEscape, lowercase: method.LowercaseUrls, encodeSlashes: parameterPart.EncodeSlashes);
                                }
                            }
                            else
                            {
                                this.WriteLineIf(shouldAppendSlash, AppendSlash);
                                shouldAppendSlash = false;

                                // write buffered value
                                this.WriteLineIf(bufferedSeparator is not null, bufferedSeparator!);
                                bufferedSeparator = null;

                                this.EmitParameter(parameter.Name, parameter.RequiresEscape, lowercase: method.LowercaseUrls, encodeSlashes: parameterPart.EncodeSlashes);
                            }
                        }
                        else if (part is RoutePatternPartLiteral literal)
                        {
                            this.WriteLineIf(shouldAppendSlash, AppendSlash);
                            shouldAppendSlash = false;

                            // write buffered value
                            this.WriteLineIf(bufferedSeparator is not null, bufferedSeparator!);
                            bufferedSeparator = null;

                            var content = method.LowercaseUrls
                                ? literal.Content.ToLowerInvariant()
                                : literal.Content;
                            _writer.WriteLine($"{RouteBuilder}.Append(\"{content}\");");
                        }
                        else if (part is RoutePatternPartSeparator separatorPart)
                        {
                            var current = $"{RouteBuilder}.Append(\"{separatorPart.Content}\");";
                            if (bufferedSeparator is null)
                            {
                                bufferedSeparator = current;
                            }
                            else
                            {
                                this.WriteLineIf(shouldAppendSlash, AppendSlash);
                                shouldAppendSlash = false;

                                _writer.WriteLine(bufferedSeparator);
                                _writer.WriteLine(current);
                                bufferedSeparator = null;
                            }
                        }
                    }
                }

                if (method.AppendTrailingSlash)
                {
                    _writer.WriteLine($$"""
                        if ({{RouteBuilder}}[^1] != '/')
                        {
                            {{AppendSlash}}
                        }
                        """);
                }

                var first = true;
                foreach (var parameter in method.Parameters)
                {
                    if (!parameter.IsQueryParameter)
                    {
                        continue;
                    }

                    // empty line between parameter checks
                    _writer.WriteLine();

                    this.WriteLineIf(first, "bool _first = true;");
                    first = false;

                    using (_writer.EmitStartBlock($"if ({parameter.Name} is not null)"))
                    {
                        var queryName = Uri.EscapeDataString(method.LowercaseQueryStrings
                            ? parameter.QueryName.ToLowerInvariant()
                            : parameter.QueryName);

                        if (parameter.IsEnumerable)
                        {
                            const string localName = "_element";
                            using (_writer.EmitStartBlock($"foreach (var {localName} in {parameter.Name})"))
                            {
                                _writer.WriteLine($"{RouteBuilder}.Append(_first ? '?' : '&');");
                                _writer.WriteLine($"{RouteBuilder}.Append(\"{queryName}=\");");
                                this.EmitParameter(localName, parameter.RequiresEscape, lowercase: method.LowercaseQueryStrings, encodeSlashes: true);

                                _writer.WriteLine();
                                _writer.WriteLine("_first = false;");
                            }
                        }
                        else
                        {
                            _writer.WriteLine($"{RouteBuilder}.Append(_first ? '?' : '&');");
                            _writer.WriteLine($"{RouteBuilder}.Append(\"{queryName}=\");");
                            this.EmitParameter(parameter.Name, parameter.RequiresEscape, lowercase: method.LowercaseQueryStrings, encodeSlashes: true);

                            _writer.WriteLine();
                            _writer.WriteLine("_first = false;");
                        }
                    }
                }

                // write return statement
                _writer.WriteLine($"return {RouteBuilder}.ToString();");
            }
            using (_writer.EmitStartBlock("finally"))
            {
                _writer.WriteLine($"{_spec.GeneratedRouteHelper}.{StringBuilderPool}.Return({RouteBuilder});");
            }
        }

        private void EmitParameter(string parameterName, bool requireEscape, bool lowercase, bool encodeSlashes)
        {
            if (!requireEscape)
            {
                _writer.WriteLine($"{RouteBuilder}.Append({parameterName});");
                return;
            }

            var lowercaseStringified = lowercase ? "true" : "false";
            var encodeSlashesStringified = encodeSlashes ? "true" : "false";

            _writer.WriteLine($"{_spec.GeneratedRouteHelper}.EncodeValue({RouteBuilder}, {parameterName}, lowercase: {lowercaseStringified}, encodeSlashes: {encodeSlashesStringified});");
        }

        private void WriteLineIf(bool first, string line)
        {
            if (first)
            {
                _writer.WriteLine(line);
            }
        }

        private static bool CanEmitInline(MethodSpec method)
        {
            foreach (var parameter in method.Parameters)
            {
                if (parameter.IsQueryParameter)
                {
                    return false;
                }

                if (parameter.RequiresEscape)
                {
                    return false;
                }
            }

            foreach (var segment in method.Pattern.PathSegments)
            {
                foreach (var part in segment.Parts)
                {
                    if (part is RoutePatternPartParameter parameter && (parameter.IsOptional || parameter.IsCatchAll || !parameter.EncodeSlashes))
                    {
                        return false;
                    }
                }
            }

            return true;
        }
    }
}
