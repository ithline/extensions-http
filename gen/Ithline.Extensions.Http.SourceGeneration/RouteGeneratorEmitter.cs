using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using Ithline.Extensions.Http.SourceGeneration.Models;

namespace Ithline.Extensions.Http.SourceGeneration;

internal static class RouteGeneratorEmitter
{
    public const string RouteHelperClass = "__GeneratedRouteHelper";
    public const string SpanOfChar = "global::System.Span<char>";
    public const string ReadOnlySpanOfChar = "global::System.ReadOnlySpan<char>";
    public const string StringBuilder = "global::System.Text.StringBuilder";

    private static string GeneratedCodeAttribute =>
        $@"[System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(RouteGeneratorEmitter).Assembly.FullName}"", ""{typeof(RouteGeneratorEmitter).Assembly.GetName().Version}"")]";

    public static void EmitFileHeader(this CodeWriter writer)
    {
        writer.WriteLine("""
            //------------------------------------------------------------------------------
            // <auto-generated>
            //     This code was generated by a tool.
            //
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>
            //------------------------------------------------------------------------------
            #nullable enable
            """);
    }

    public static void EmitHelper(this CodeWriter writer)
    {
        const string AggressiveInlining = "global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)";

        writer.WriteLine($$"""
            {{GeneratedCodeAttribute}}
            file static class {{RouteHelperClass}}
            {
                private static readonly global::Microsoft.Extensions.ObjectPool.ObjectPool<{{StringBuilder}}> _pool = global::Microsoft.Extensions.ObjectPool.ObjectPool.Create(
                    new global::Microsoft.Extensions.ObjectPool.StringBuilderPooledObjectPolicy());
                private static readonly global::System.Text.Encodings.Web.UrlEncoder _encoder = global::System.Text.Encodings.Web.UrlEncoder.Default;

                [{{AggressiveInlining}}]
                public static {{StringBuilder}} Rent()
                {
                    return _pool.Get();
                }

                [{{AggressiveInlining}}]
                public static void Return({{StringBuilder}} obj)
                {
                    _pool.Return(obj);
                }

                [{{AggressiveInlining}}]
                public static bool IsNull<T>([global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(false)] T? value)
                {
                    return value is null;
                }

                [{{AggressiveInlining}}]
                public static string Encode(string? value)
                {
                    return _encoder.Encode(value ?? string.Empty);
                }

                public static void EncodeSpan({{StringBuilder}} sb, {{ReadOnlySpanOfChar}} s, {{SpanOfChar}} buffer)
                {
                    global::System.Buffers.OperationStatus status;
                    global::System.Text.Encodings.Web.UrlEncoder encoder = _encoder;
                    do
                    {
                        status = encoder.Encode(s, buffer, out int consumed, out int written, isFinalBlock: s.IsEmpty);

                        sb.Append(buffer.Slice(0, written));
                        s = s.Slice(consumed);
                    }
                    while (status != global::System.Buffers.OperationStatus.Done);
                }
            }
            """);
    }

    public static void EmitMethods(this CodeWriter writer, IEnumerable<PatternMethod> methods)
    {
        var lookup = methods.GroupBy(t => t.ContainingType);
        foreach (var group in lookup)
        {
            if (!string.IsNullOrWhiteSpace(group.Key.Namespace))
            {
                writer.WriteLine($"namespace {group.Key.Namespace}");
                writer.StartBlock(); // start namespace block
            }

            var current = group.Key;
            var stack = new Stack<PatternType>();
            while (current is not null)
            {
                stack.Push(current);
                current = current.Parent;
            }

            foreach (var pt in stack)
            {
                writer.WriteLine($"partial {pt.Keyword} {pt.TypeName}");
                writer.StartBlock(); // start type block
            }

            var first = true;
            foreach (var method in group)
            {
                if (!first)
                {
                    writer.WriteLine();
                }
                first = false;

                writer.EmitMethod(method);
            }

            foreach (var _ in stack)
            {
                writer.EndBlock(); // end type block
            }

            if (!string.IsNullOrWhiteSpace(group.Key.Namespace))
            {
                writer.EndBlock(); // end namespace block
            }
        }
    }

    private static void EmitMethod(this CodeWriter writer, PatternMethod method)
    {
        writer.WriteLine(GeneratedCodeAttribute);
        writer.EmitMethodSignature(method);
        writer.StartBlock(); // start method body

        // due to some perf issues, we don't want to emit interpolated string
        if (method.Parameters.Count == 0)
        {
            writer.EmitMethodBodyInline(method);
        }
        else
        {
            writer.EmitMethodBodyStringBuilder(method);
        }

        writer.EndBlock(); // close method body
    }

    private static void EmitMethodSignature(this CodeWriter writer, PatternMethod method)
    {
        var sb = new StringBuilder();
        if (!string.IsNullOrWhiteSpace(method.MethodModifiers))
        {
            sb.Append(method.MethodModifiers).Append(' ');
        }

        sb.Append("string ").Append(method.MethodName);
        sb.Append('(');

        var first = true;
        foreach (var parameter in method.Parameters)
        {
            if (!first)
            {
                sb.Append(", ");
            }
            first = false;

            sb.Append(parameter.ParameterType);
            sb.Append(" ");
            sb.Append(parameter.ParameterName);
        }

        sb.Append(')');

        writer.WriteLine(sb.ToString());
    }

    private static void EmitMethodBodyInline(this CodeWriter writer, PatternMethod method)
    {
        var sb = new StringBuilder();
        foreach (var segment in method.Segments)
        {
            sb.Append('/');
            foreach (var part in segment)
            {
                if (part is PatternLiteral literal)
                {
                    var content = method.LowercaseUrls
                        ? literal.Content.ToLowerInvariant()
                        : literal.Content;

                    sb.Append(content);
                }
                else
                {
                    Debug.Fail("This should be handled by check if method can be inlined.");
                }
            }
        }

        if (sb.Length == 0 || (method.AppendTrailingSlash && sb[^1] != '/'))
        {
            sb.Append('/');
        }

        writer.WriteLine($@"return $""{sb}"";");
    }

    private static void EmitMethodBodyStringBuilder(this CodeWriter writer, PatternMethod method)
    {
        const string RouteBuilder = "__sb";
        const string Buffer = "__buffer";
        const string FirstQueryName = "__firstQuery";
        const string AppendSlash = $"{RouteBuilder}.Append('/');";
        const string AppendSeparator = $"{RouteBuilder}.Append({FirstQueryName} ? '?' : '&');";

        writer.WriteLine($"// {method.RawPattern}");
        writer.WriteLine($"{StringBuilder} {RouteBuilder} = {RouteHelperClass}.Rent();");
        writer.WriteLine("try");
        writer.StartBlock(); // start try

        // allocate encoding buffer
        writer.WriteLine($"{SpanOfChar} {Buffer} = stackalloc char[64];");

        bool builderEmpty = true;
        foreach (var segment in method.Segments)
        {
            var segmentStarted = true;

            writer.WriteLine();
            writer.WriteLine($"// /{segment}");
            foreach (var part in segment)
            {
                if (part is PatternLiteral literal)
                {
                    var content = method.LowercaseUrls
                        ? literal.Content.ToLowerInvariant()
                        : literal.Content;

                    if (segmentStarted)
                    {
                        content = '/' + content;
                    }
                    segmentStarted = false;

                    writer.WriteLine($@"{RouteBuilder}.Append(""{content}"");");

                    builderEmpty = false;
                }
                else if (part is RoutePatternParameter parameter)
                {
                    // for optional parameters, we emit null checks
                    if (parameter.IsNullable)
                    {
                        writer.WriteLine($"if ({parameter.ParameterName} is not null)");
                        writer.StartBlock();
                    }

                    // if parameter is first value in segment, we emit slash
                    if (segmentStarted)
                    {
                        writer.WriteLine(AppendSlash);
                    }
                    segmentStarted = false;

                    // we emit separator in case we have value
                    if (parameter.HasOptionalSeparator)
                    {
                        writer.WriteLine($"{RouteBuilder}.Append('.');");
                    }

                    EmitParameterValue(writer, parameter, method);

                    if (parameter.IsNullable)
                    {
                        writer.EndBlock();
                    }
                    else
                    {
                        builderEmpty = false;
                    }
                }
                else
                {
                    Debug.Fail("This is not valid case.");
                }
            }
        }

        // if builder can be empty, we need to check
        if (builderEmpty)
        {
            writer.WriteLine();
            writer.WriteLine($"if ({RouteBuilder}.Length == 0)");
            writer.StartBlock();
            writer.WriteLine(AppendSlash);
            writer.EndBlock();
        }
        else if (method.AppendTrailingSlash)
        {
            writer.WriteLine();
            writer.WriteLine($"if ({RouteBuilder}.Length == 0 || {RouteBuilder}[^1] != '/')");
            writer.StartBlock();
            writer.WriteLine(AppendSlash);
            writer.EndBlock();
        }

        var firstQuery = true;
        foreach (var parameter in method.Parameters.OfType<QueryPatternParameter>())
        {

            var queryName = Uri.EscapeDataString(method.LowercaseQueryStrings
                ? parameter.QueryName.ToLowerInvariant()
                : parameter.QueryName);
            var appendQueryName = $@"{RouteBuilder}.Append(""{queryName}="");";

            writer.WriteLine();
            if (firstQuery)
            {
                writer.WriteLine($"bool {FirstQueryName} = true;");
            }
            firstQuery = false;

            writer.WriteLine($"if (!{RouteHelperClass}.IsNull({parameter.ParameterName}))");
            writer.StartBlock();

            if (parameter.IsEnumerable)
            {
                writer.WriteLine($"foreach (var {parameter.EmitElementArgument()} in {parameter.ParameterName})");
                writer.StartBlock();

                writer.WriteLine($"if (!{RouteHelperClass}.IsNull({parameter.EmitElementArgument()}))");
                writer.StartBlock();
                writer.WriteLine(AppendSeparator);
                writer.WriteLine(appendQueryName);
                EmitParameterValue(writer, parameter, method);
                writer.WriteLine($"{FirstQueryName} = false;");
                writer.EndBlock();

                writer.EndBlock();
            }
            else
            {
                writer.WriteLine(AppendSeparator);
                writer.WriteLine(appendQueryName);
                EmitParameterValue(writer, parameter, method);
                writer.WriteLine($"{FirstQueryName} = false;");
            }

            writer.EndBlock();
        }

        if (method.Fragment is FragmentPatternParameter fragment)
        {
            writer.WriteLine();
            writer.WriteLine($"if (!{RouteHelperClass}.IsNull({fragment.ParameterName}))");
            writer.StartBlock();
            writer.WriteLine($"{RouteBuilder}.Append('#');");
            EmitParameterValue(writer, fragment, method);
            writer.EndBlock();
        }

        writer.WriteLine($"return {RouteBuilder}.ToString();");

        writer.EndBlock(); // end try

        writer.WriteLine("finally");
        writer.StartBlock();
        writer.WriteLine($"{RouteHelperClass}.Return({RouteBuilder});");
        writer.EndBlock();

        static void EmitParameterValue(CodeWriter writer, PatternParameter parameter, PatternMethod method)
        {
            // we can still inline integers without extra conversions
            if (parameter.IsInteger)
            {
                var valueSuffix = parameter.IsNullable ? ".Value" : string.Empty;
                writer.WriteLine($@"{RouteBuilder}.Append({parameter.EmitElementArgument()}{valueSuffix});");
                return;
            }

            var tempArgument = parameter.EmitTempArgument();

            // emit string conversion
            writer.WriteLine($"{ReadOnlySpanOfChar} {tempArgument} = {parameter.EmitConvertToString(method)};");

            // if we have to encode slashes, we emit split first and then default encode will handle the rest
            if (parameter is RoutePatternParameter { EncodeSlashes: false })
            {
                var tempArgument_i = $"{tempArgument}_i";
                writer.WriteLine($"int {tempArgument_i};");
                writer.WriteLine($"while (({tempArgument_i} = {tempArgument}.IndexOf('/')) >= 0)");
                writer.StartBlock();
                writer.WriteLine($"{RouteHelperClass}.EncodeSpan({RouteBuilder}, {tempArgument}.Slice(0, {tempArgument_i}), {Buffer});");
                writer.WriteLine(AppendSlash);
                writer.WriteLine($"{tempArgument} = {tempArgument}.Slice({tempArgument_i} + 1);");
                writer.EndBlock();
            }

            writer.WriteLine($"{RouteHelperClass}.EncodeSpan({RouteBuilder}, {tempArgument}, {Buffer});");
        }
    }

    private static string EmitConvertToString(this PatternParameter parameter, PatternMethod method)
    {
        var lowercase = false;
        lowercase |= parameter is QueryPatternParameter qp && (qp.IsLowercase || method.LowercaseQueryStrings);
        lowercase |= parameter is RoutePatternParameter && method.LowercaseUrls;

        var toLowerInvariant = lowercase ? "?.ToLowerInvariant()" : string.Empty;
        if (parameter.IsString)
        {
            return $"{parameter.EmitElementArgument()}{toLowerInvariant}";
        }

        return $"global::System.Convert.ToString({parameter.EmitElementArgument()}, global::System.Globalization.CultureInfo.InvariantCulture){toLowerInvariant}";
    }
    private static string EmitTempArgument(this PatternParameter parameter) => $"{parameter.ParameterName}_temp";
    private static string EmitElementArgument(this PatternParameter parameter) => parameter is QueryPatternParameter { IsEnumerable: true }
        ? $"{parameter.ParameterName}_element"
        : parameter.ParameterName;
}
